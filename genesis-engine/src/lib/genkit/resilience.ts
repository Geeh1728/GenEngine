import { ai, geminiFlash, geminiPro } from './config';
import { z } from 'genkit';

import { MessageData } from 'genkit';

interface ResilienceOptions<T extends z.ZodTypeAny> {
    prompt: string | MessageData['content'];
    schema: T;
    system?: string;
    model?: string;
    tools?: any[];
    config?: any;
    retryCount?: number;
    fallback?: z.infer<T>; // Add this
    onLog?: (message: string, type: 'INFO' | 'ERROR' | 'SUCCESS' | 'THINKING') => void;
}

export async function generateWithResilience<T extends z.ZodTypeAny>(
    options: ResilienceOptions<T>
): Promise<z.infer<T> | null> {
    const { prompt, schema, system, model, tools, config, retryCount = 2, fallback, onLog } = options;

    let attempts = 0;
    // Use provided model name if available, otherwise default to geminiFlash
    let currentModel = model ? { name: model, label: model } : geminiFlash; 
    let currentPrompt: MessageData['content'] = Array.isArray(prompt) ? prompt : [{ text: prompt }];

    while (attempts <= retryCount) {
        try {
            console.log(`[Resilience] Attempt ${attempts + 1}/${retryCount + 1} using ${currentModel.label}`);
            if (onLog) onLog(`Attempt ${attempts + 1}: Compiling via ${currentModel.label}...`, 'THINKING');

            const response = await ai.generate({
                model: currentModel.name,
                prompt: currentPrompt,
                system: system,
                tools: tools,
                config: config,
                output: {
                    schema: schema,
                },
            });

            if (response.output) {
                if (onLog) onLog(`Attempt ${attempts + 1}: Success.`, 'SUCCESS');
                return response.output;
            } else {
                console.log("[Resilience] Raw response text (no structured output):", response.text);
                throw new Error("No structured output generated by model.");
            }

        } catch (error: unknown) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`[Resilience] Attempt ${attempts + 1} failed:`, errorMessage);
            if (onLog) onLog(`Attempt ${attempts + 1} failed: ${errorMessage.substring(0, 50)}...`, 'ERROR');
            
            // ... (rest of catch block)
            attempts++;

            if (attempts > retryCount) break;

            // Strategy 1: Fallback Model on specific infrastructure errors (429/500)
            if (attempts === 1 && (errorMessage.includes('429') || errorMessage.includes('500'))) {
                console.warn('[Resilience] Switching to Fallback Model (Gemini 2.5 Flash) due to rate limit/error.');
                if (onLog) onLog('Rate limit hit. Switching to high-capacity model...', 'INFO');
                currentModel = geminiPro;
                continue;
            }

            // Strategy 2: Self-Correction Loop for Schema/Parsing errors
            console.warn(`[Resilience] Initiating Self-Correction for attempt ${attempts + 1}...`);
            if (onLog) onLog('Initiating autonomous self-correction loop...', 'THINKING');
            
            currentPrompt = [
                ...currentPrompt,
                { text: `\n\nCRITICAL ERROR: Your previous response failed validation with the following error: "${errorMessage}". Please fix the JSON structure or types and try again. Ensure you match the requested schema exactly.` }
            ];
        }
    }

    console.error('[Resilience] All attempts failed.');
    if (onLog) onLog('All autonomous correction attempts failed. Using fallback.', 'ERROR');
    return fallback || null;
}
