import { ai, geminiFlash, geminiPro } from './config';
import { z } from 'genkit';

import { MessageData } from 'genkit';

interface ResilienceOptions<T extends z.ZodTypeAny> {
    prompt: string | MessageData['content'];
    schema: T;
    system?: string;
    retryCount?: number;
}

export async function generateWithResilience<T extends z.ZodTypeAny>(
    options: ResilienceOptions<T>
): Promise<z.infer<T> | null> {
    const { prompt, schema, system, retryCount = 2 } = options;

    let attempts = 0;
    let currentModel = geminiFlash; // Start with Lite (Quota friendly)
    let currentPrompt: MessageData['content'] = Array.isArray(prompt) ? prompt : [{ text: prompt }];

    while (attempts <= retryCount) {
        try {
            console.log(`[Resilience] Attempt ${attempts + 1}/${retryCount + 1} using ${currentModel.label || 'Gemini'}`);

            const response = await ai.generate({
                model: currentModel.name,
                prompt: currentPrompt,
                system: system,
                output: {
                    schema: schema,
                },
            });

            if (response.output) {
                return response.output;
            } else {
                console.log("[Resilience] Raw response text (no structured output):", response.text());
                throw new Error("No structured output generated by model.");
            }

        } catch (error: unknown) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`[Resilience] Attempt ${attempts + 1} failed:`, errorMessage);
            
            // Log raw error details if available
            if (error && typeof error === 'object' && 'response' in error) {
                try {
                    // @ts-expect-error - Checking for response text in error
                    console.log("[Resilience] Error Response Text:", error.response.text());
                } catch (e) {}
            }

            attempts++;

            if (attempts > retryCount) break;

            // Strategy 1: Fallback Model on specific infrastructure errors (429/500)
            if (attempts === 1 && (errorMessage.includes('429') || errorMessage.includes('500'))) {
                console.warn('[Resilience] Switching to Fallback Model (Gemini 2.5 Flash) due to rate limit/error.');
                currentModel = geminiPro;
                continue;
            }

            // Strategy 2: Self-Correction Loop for Schema/Parsing errors
            // We feed the error back to the AI so it can fix its own JSON.
            console.warn(`[Resilience] Initiating Self-Correction for attempt ${attempts + 1}...`);
            
            currentPrompt = [
                ...currentPrompt,
                { text: `\n\nCRITICAL ERROR: Your previous response failed validation with the following error: "${errorMessage}". Please fix the JSON structure or types and try again. Ensure you match the requested schema exactly.` }
            ];
        }
    }

    console.error('[Resilience] All attempts failed.');
    return null;
}
